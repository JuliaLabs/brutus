# TODO: In future, should be autogenerated from tablegen.

function create_unimplemented_op(loc::JLIR.Location, type)
    state = JLIR.create_operation_state("jlir::unimplemented", loc)
    JLIR.push_results!(state, 1, type)
    return JLIR.Operation(state)
end

function create_constant_op(loc::JLIR.Location, value, type)
    state = JLIR.create_operation_state("jlir::constant", loc)
    JLIR.push_operands!(state, 1, value)
    JLIR.push_results!(state, 1, type)
    return JLIR.Operation(state)
end

function create_goto_op(loc::JLIR.Location, blk::JLIR.Block, 
        v::Vector{JLIR.Value})
    state = JLIR.create_operation_state("jlir::goto", loc)
    JLIR.push_operands!(state, v)
    JLIR.push_successors!(state, JLIR.Block[blk])
    return JLIR.Operation(state)
end

function create_gotoifnot_op(loc::JLIR.Location, cond::JLIR.Value, 
        dest::JLIR.Block, v::Vector{JLIR.Value}, 
        fall::JLIR.Block, fallv::Vector{JLIR.Value})
    state = JLIR.create_operation_state("jlir::gotoifnot", loc)
    JLIR.push_operands!(state, JLIR.Value[cond])
    JLIR.push_operands!(state, v)
    JLIR.push_operands!(state, fallv)
    JLIR.push_successors!(state, JLIR.Block[blk])
    JLIR.push_successors!(state, JLIR.Block[fall])
    return JLIR.Operation(state)
end

function create_pi_op(loc::JLIR.Location, input::JLIR.Type, 
        type::JLIR.Type)
    state = JLIR.create_operation_state("jlir::pi", loc)
    JLIR.push_operands!(state, JLIR.Type[value])
    JLIR.push_results!(state, JLIR.Type[type])
    return JLIR.Operation(state)
end

function create_return_op(loc::JLIR.Location, input::JLIR.Type)
    state = JLIR.create_operation_state("jlir::return", loc)
    JLIR.push_operands!(state, JLIR.Type[input])
    return JLIR.Operation(state)
end

function create_call_op(loc::JLIR.Location, callee::JLIR.Type, 
        arguments::Vector{JLIR.Type}, type::JLIR.Type)
    state = JLIR.create_operation_state("jlir::call", loc)
    operands = [callee, arguments...]
    JLIR.push_operands!(state, operands)
    JLIR.push_results!(state, JLIR.Value[type])
    return JLIR.Operation(state)
end

function create_invoke_op(loc::JLIR.Location, mi::JLIR.Value, 
        callee::JLIR.Value, arguments::Vector{JLIR.Value}, 
        type::JLIR.Type)
    state = JLIR.create_operation_state("jlir::invoke", loc)
    JLIR.push_operands!(state, JLIR.Value[mi, callee, arguments...])
    JLIR.push_results!(state, JLIR.Value[type])
    return JLIR.Operation(state)
end

#####
##### High-level version of create<OpType>
#####

struct UnimplementedOp end
struct ConstantOp end
struct GotoOp end
struct GotoIfNotOp end
struct PiOp end
struct ReturnOp end
struct CallOp end
struct InvokeOp end

function create!(b::JLIRBuilder, ::UnimplementedOp, loc::JLIR.Location,
        type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_unimplemented_op(loc, type)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::ConstantOp, loc::JLIR.Location, 
        value::JLIR.Value, type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_constant_op(loc, value, type)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::GotoOp, loc::JLIR.Location, 
        blk::JLIR.Block, v::Vector{JLIR.Value})
    @assert(isdefined(b, :blocks))
    op = create_goto_op(loc, blk, v)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::GotoIfNotOp, loc::JLIR.Location, 
        cond::JLIR.Value, dest::JLIR.Block, v::Vector{JLIR.Value}, 
        fall::JLIR.Block, fallv::Vector{JLIR.Value})
    @assert(isdefined(b, :blocks))
    op = create_gotoifnot_op(loc, cond, dest, v, fall, fallv)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::PiOp, loc::JLIR.Location, 
        value::JLIR.Value, type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_pi_op(loc, value, type)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::ReturnOp, loc::JLIR.Location, 
        input::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_return_op(loc, input)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::CallOp, loc::JLIR.Location, 
        callee::JLIR.Value, arguments::Vector{JLIR.Value}, 
        type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_call_op(loc, callee, arguments, type)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::InvokeOp, loc::JLIR.Location, 
        mi::Core.MethodInstance, callee::JLIR.Value, 
        arguments::Vector{JLIR.Value}, type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    jlir_mi = convert_value_to_jlirattr(b, mi)
    op = create_invoke_op(loc, jlir_mi, callee, arguments, type)
    JLIR.verify(op)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end
