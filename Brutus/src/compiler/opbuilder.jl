#####
##### Builder
#####

# High-level version of MLIR's OpBuilder.

mutable struct JLIRBuilder
    ctx::JLIR.Context
    values::Vector{JLIR.Value}
    arguments::Vector{JLIR.Value}
    insertion::Int
    blocks::Vector{JLIR.Block}
    function JLIRBuilder()
        ctx = JLIR.create_context()
        ccall((:brutus_register_dialects, "libbrutus"),
              Cvoid,
              (JLIR.Context, ),
              ctx)
        new(ctx, JLIR.Value[], JLIR.Value[], 1)
    end
end

set_insertion!(b::JLIRBuilder, blk::Int) = b.insertion = blk

function push!(b::JLIRBuilder, op::JLIR.Operation)
    @assert(isdefined(b, :blocks))
    blk = b.blocks[b.insertion]
    push_operation!(blk, op)
end

#####
##### Utilities
#####

function convert_type_to_mlir(builder::JLIRBuilder, a)
    ctx = builder.ctx
    return ccall((:brutus_get_juliatype, "libbrutus"), 
                 JLIR.Type, 
                 (JLIR.Context, Any), 
                 ctx, a)
end

function get_functype(builder::JLIRBuilder, args::Vector{JLIR.Type}, ret::JLIR.Type)
    return MLIR.API.mlirFunctionTypeGet(builder.ctx, length(args), args, 1, [ret])
end

function get_functype(builder::JLIRBuilder, args, ret)
    return get_functype(builder, length(args), map(args) do a
                            convert_type_to_mlir(builder, a)
                        end, 1, [convert_type_to_mlir(builder, ret)])
end

function unwrap(mi::Core.MethodInstance)
    return mi.def.value
end
unwrap(s) = s

function extract_linetable_meta(builder::JLIRBuilder, v::Vector{Core.LineInfoNode})
    locations = JLIR.Location[]
    for n in v
        method = unwrap(n.method)
        file = String(n.file)
        line = n.line
        inlined_at = n.inlined_at
        if method isa Method
            fname = String(method.name)
        end
        if method isa Symbol
            fname = String(method)
        end
        current = JLIR.Location(builder.ctx, fname, UInt32(line), UInt32(0)) # TODO: col.
        if inlined_at > 0
            current = JLIR.Location(current, locations[inlined_at - 1])
        end
        push!(locations, current)
    end
    return locations
end

#####
##### High-level version of create<OpType>
#####

# In future, should be autogenerated from tablegen.

struct UnimplementedOp end
struct ConstantOp end
struct GotoOp end
struct GotoIfNotOp end
struct PiOp end
struct CallOp end

function create!(b::JLIRBuilder, ::UnimplementedOp, loc, type)
    @assert(isdefined(b, :blocks))
    op = create_unimplemented_op(loc, type)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::ConstantOp, loc, value, type)
    @assert(isdefined(b, :blocks))
    op = create_constant_op(loc, value, type)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::GotoOp, loc::JLIR.Location, blk::JLIR.Block, v::Vector{JLIR.Value})
    @assert(isdefined(b, :blocks))
    op = create_goto_op(loc, blk, v)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::GotoIfNotOp, loc::JLIR.Location, 
        cond::JLIR.Value, dest::JLIR.Block, v::Vector{JLIR.Value}, 
        fall::JLIR.Block, fallv::Vector{JLIR.Value})
    @assert(isdefined(b, :blocks))
    op = create_gotoifnot_op(loc, cond, dest, v, fall, fallv)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::PiOp, loc, value::JLIR.Value, type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_pi_op(loc, value, type)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

function create!(b::JLIRBuilder, ::CallOp, loc, callee::JLIR.Value, arguments::Vector{JLIR.Value}, type::JLIR.Type)
    @assert(isdefined(b, :blocks))
    op = create_call_op(loc, callee, arguments, type)
    blk = getindex(b.blocks, b.insertion)
    push!(blk, op)
    return op
end

#####
##### JLIR emission
#####

function emit_value(builder::JLIRBuilder, loc::JLIR.Location, value::GlobalRef, type)
    name = value.name
    v = getproperty(value.mod, value.name)
    return create_constant_op(builder, loc, v, type)
end

function emit_value(builder::JLIRBuilder, loc::JLIR.Location, value::Core.SSAValue, type)
    @assert(value.id >= 1)
    return getindex(builder.values, value.id)
end

function emit_value(builder::JLIRBuilder, loc::JLIR.Location, value, type)
    return create_unimplemented_op(builder, loc, type)
end

function emit_ftype(builder::JLIRBuilder, ir_code::Core.Compiler.IRCode, ret_type)
    argtypes = getfield(ir_code, :argtypes)
    nargs = length(argtypes)
    args = [convert_type_to_mlir(builder, a) for a in argtypes]
    ret = convert_type_to_mlir(builder, ret_type)
    return get_functype(builder, args, ret)
end

function process_node!(b::JLIRBuilder)
end

function walk_cfg_emit_branchargs(builder, 
        cfg::Core.Compiler.CFG, current_block::Int, 
        target_block::Int, stmts, types, loc::JLIR.Location)
    v = JLIR.Value[]
    for stmt in cfg.blocks[target].stmts
        handle_node!(builder, v, stmt, loc)
    end
    return v
end

function create_func_op(builder::JLIRBuilder, 
        ir_code::Core.Compiler.IRCode, ret::Type, name::String)

    # Setup.
    irstream = ir_code.stmts
    location_indices = getfield(irstream, :line)
    linetable = getfield(ir_code, :linetable)
    locations = extract_linetable_meta(builder, linetable)
    argtypes = getfield(ir_code, :argtypes)
    args = [convert_type_to_mlir(builder, a) for a in argtypes]
    state = JLIR.create_operation_state(name, locations[1])
    entry_blk, reg = JLIR.add_entry_block!(state, args)
    cfg = ir_code.cfg
    cfg_blocks = cfg.blocks
    nblocks = length(cfg_blocks)
    blocks = JLIR.Block[JLIR.push_new_block!(reg) for _ in 1 : nblocks]
    pushfirst!(blocks, entry_blk)
    builder.blocks = blocks
    stmts = irstream.inst
    types = irstream.type
    v = walk_cfg_emit_branchargs(builder, cfg, 1, 2, stmts, types, locations[0])
    goto = create_goto_op(Location(builder.ctx), blocks[2], v)
    push!(builder, goto)
    set_insertion!(builder, 2)

    # Process.
    for (ind, (stmt, type)) in enumerate(zip(stmts, types))
        loc = linetable[ind] == 0 ? JLIR.Location() : locations[ind]
        is_terminator = false
        process_node!(builder, stmt, loc)
    end
   
    # Create op from state and verify.
    op = JLIR.Operation(state)
    @assert(JLIR.verify(op))
    return op
end

function create_func_op(ir_code::Core.Compiler.IRCode, ret::Type, name::String)
    b = JLIRBuilder()
    return create_func_op(b, ir_code, ret, name)
end
